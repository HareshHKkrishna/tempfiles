/*
 * Auto-generated SoC Top-Level
 * DO NOT EDIT MANUALLY
 */

`ifndef PICORV32_REGS
`ifdef PICORV32_V
`error "{{ soc.name }}.v must be read before picorv32.v!"
`endif

`define PICORV32_REGS picosoc_regs
`endif

`ifndef PICOSOC_MEM
`define PICOSOC_MEM picosoc_mem
`endif

`define PICOSOC_V

module {{ soc.name }} (
	input clk,
	input resetn,

	output        iomem_valid,//cpu requests a transaction
	input         iomem_ready,//peripeheral signal completion
	output [ 3:0] iomem_wstrb,//byte enable signals
	output [31:0] iomem_addr,//address of memory mapped peripheral
	output [31:0] iomem_wdata,//date to write to peripheral
	input  [31:0] iomem_rdata,//data read from peripheral

    {% for irq_name, irq_num in soc.interrupts.assignments.items() -%}
        input {{ irq_name }},{% if not loop.last %}{% endif %}
    {% endfor %}
    {% for p in soc.peripherals -%}
    {% for port_name, port_info in p.top_ports.items() -%}
            {{ port_info.dir }} {{ port_name }},{% if not loop.last %}{% endif %}
    {% endfor -%}
    {% endfor -%}


);
    {% include "core/picorv32_params.v.j2" %}

    reg [31:0] irq;
    wire irq_stall = 0;

    always @* begin
        irq = 0;
        irq[3] = irq_stall;
        {% for irq_name, irq_num in soc.interrupts.assignments.items() -%}
        irq[{{ irq_num }}] = {{ irq_name }};
        {% endfor -%}
        end

    wire mem_valid;
	wire mem_instr;
	wire mem_ready;
	wire [31:0] mem_addr;
	wire [31:0] mem_wdata;
	wire [3:0] mem_wstrb;
	wire [31:0] mem_rdata;

    assign iomem_valid = mem_valid && (mem_addr[31:24] > 8'h 01);
	assign iomem_wstrb = mem_wstrb;
	assign iomem_addr = mem_addr;
	assign iomem_wdata = mem_wdata;

{% for p in soc.peripherals -%}
            {% include "peripherals/" ~ p.type ~ "/iface_" ~ p.bus_type ~ ".v.j2" -%}
    {% endfor %}

assign mem_ready =
    (iomem_valid && iomem_ready)
    {% for p in soc.peripherals -%}
    {% for bus, bind in p.bus_bindings.items() -%}
    {% if bind.roles.resp.ready is defined -%}
    || {{ bind.roles.resp.ready }}
    {% endif -%}
    {% endfor -%}
    {% endfor -%}
    {% for p in soc.peripherals -%}
    {% if p.parameters.registers is defined -%}
    {% for reg_name, reg in p.parameters.registers.items() -%}
    {% if reg.wait is defined and reg.wait -%}
    || ({{ p.name }}_{{ reg_name }}_sel && !{{ p.name }}_{{ reg_name }}_wait)
    {% else -%}
    || {{ p.name }}_{{ reg_name }}_sel
    {% endif -%}
    {% endfor -%}
    {% endif -%}
    {% endfor -%}|| ram_ready;


assign mem_rdata =
    (iomem_valid && iomem_ready) ? iomem_rdata
    {% for p in soc.peripherals -%}
    {% for bus, bind in p.bus_bindings.items() -%}
    {% if bind.roles.resp.ready is defined and bind.roles.resp.rdata is defined -%}
    : {{ bind.roles.resp.ready }} ? {{ bind.roles.resp.rdata }}
    {% endif -%}
    {% endfor -%}
    {% endfor -%}
    : ram_ready ? ram_rdata
    {% for p in soc.peripherals -%}
    {% if p.parameters.registers is defined -%}
    {% for reg_name, reg in p.parameters.registers.items() -%}
    : {{ p.name }}_{{ reg_name }}_sel ? {{ p.name }}_{{ reg_name }}_do
    {% endfor -%}
    {% endif -%}
    {% endfor -%}
    : 32'h0000_0000;

    {% include "core/" ~ soc.cpu.type ~ ".v.j2" %}

    always @(posedge clk)
    ram_ready <= mem_valid && !mem_ready && mem_addr < 4*{{ soc.cpu.parameters.MEM_WORDS }};

    `PICOSOC_MEM #(
        .WORDS({{ soc.cpu.parameters.MEM_WORDS }})
    ) memory (
        .clk(clk),
        .wen((mem_valid && !mem_ready && mem_addr < 4*MEM_WORDS) ? mem_wstrb : 4'b0),
        .addr(mem_addr[23:2]),
        .wdata(mem_wdata),
        .rdata(ram_rdata)
    );
endmodule
    module picosoc_regs (
        input clk, wen,
        input [5:0] waddr,
        input [5:0] raddr1,
        input [5:0] raddr2,
        input [31:0] wdata,
        output [31:0] rdata1,
        output [31:0] rdata2
    );
        reg [31:0] regs [0:31];

        always @(posedge clk)
            if (wen) regs[waddr[4:0]] <= wdata;

        assign rdata1 = regs[raddr1[4:0]];
        assign rdata2 = regs[raddr2[4:0]];
    endmodule

    module picosoc_mem #(
        parameter integer WORDS = 256
    ) (
        input clk,
        input [3:0] wen,
        input [21:0] addr,
        input [31:0] wdata,
        output reg [31:0] rdata
    );
        reg [31:0] mem [0:WORDS-1];

        always @(posedge clk) begin
            rdata <= mem[addr];
            if (wen[0]) mem[addr][ 7: 0] <= wdata[ 7: 0];
            if (wen[1]) mem[addr][15: 8] <= wdata[15: 8];
            if (wen[2]) mem[addr][23:16] <= wdata[23:16];
            if (wen[3]) mem[addr][31:24] <= wdata[31:24];
        end
    endmodule

